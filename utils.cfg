#!/bin/bash

# getInfo
# Returns info about a device by reference in the first parameter
# Allows for fdisk output not being in disk order
# Usage:
# declare -A <variable>
# getInfo <variable> <device> # e.g. getInfo source_info /dev/sda
# updates <variable> before returning
# Fields:
#	fdisk_output	[string] the output from fdisk for <device>
#	last_sector		[integer] the last used sector
#	sector_size  	[integer] the sector size in bytes
#   used_bytes		[integer] the total used space in bytes
#	used_mb			[integer] the total used space in Mb (rounded up)
#	used_gb			[string] the total used space in Gb
#   total_sectors	[integer] the total number of used sectors
#	total_bytes		[integer] the total number of bytes
#	no_of_partitions[integer] the total number of partitions

# updated 29-8-2025

getInfo() {
	# assign local variable to $1 by reference
        local -n ret=$1
	# get the fdisk output
        ret[fdisk_output]="$(fdisk -l  $2)"
        ret[last_sector]=0
	ret[no_of_partitions]=0
	local lines
	local i=0
	local items
	local device
	# break the fdisk output into an array of lines
	IFS=$'\n' lines=(${ret[fdisk_output]})
	unset IFS
	while [ $i -lt ${#lines[@]} ]; do
		local line="${lines[$i]}"
		# replace annoying * which expands to a directory search (see "gobling")
		line="${line/\*/ }"
		if [ $i -eq 0 ] ; then
			# e.g. line= "Disk mnt/Backup.img: 6.81 GiB, 7316963328 bytes, 14290944 sectors"
			# split line by ':' into items
			IFS=':' read -a items <<< "$line"
			unset IFS
			# split item1 0 by ' ' into items1
			# e.g. "Disk mnt/Backup.img"
			local items1
			IFS=' ' read -a items1 <<< "${items[0]}"
			unset IFS
			device=${items1[1]}
			# to get sizes, split items1[1] by ','
			# e.g. 6.81 GiB, 7316963328 bytes, 14290944 sectors
			IFS=',' read -a items1 <<< "${items[1]}"
			unset IFS
			# to get the total bytes split items1[1] by ' '
			# e.g.  7316963328 bytes
			local items2
			IFS=' ' read -a items2 <<< "${items1[1]}"
			unset IFS
			ret[total_bytes]=${items2[0]}
			# to get total sectors split items1[2] by ' '
			# e.g.  14290944 sectors
			IFS=' ' read -a items2 <<< "${items1[2]}"
			unset IFS
			ret[total_sectors]=${items2[0]}
		else
			if [ "${line:0:${#device}}" == $device ] ; then
				# line contains partition information
				# break line into array (by spaces)
				IFS=' ' read -a items <<< "$line"
				unset IFS
						local end_sector=${items[2]}
						if [[ $end_sector -gt ${ret[last_sector]} ]] ; then
								ret[last_sector]=$end_sector
						fi
				ret[no_of_partitions]=$((ret[no_of_partitions]+1))
			elif [ "${line:0:11}" == "Sector size" ]; then
				# line contains sector size info
				# break by : and select second field
				items=($(echo "$line" | cut -d ':' -f 2))
				ret[sector_size]=${items[0]}
			fi
		fi
		i=$((i+1))
	done
	ret[used_bytes]=$((${ret[sector_size]} * (${ret[last_sector]} + 1)))
	ret[used_mb]=$((${ret[used_bytes]} / 1024 / 1024))
	if [ $((${ret[used_mb]} * 1024 * 1024)) -lt $((${ret[used_bytes]})) ] ; then
		# round up
		ret[used_mb]=$((${ret[used_mb]} + 1))
	fi
	# get the used space as a STRING to 2 decimal places (N.B. bash only uses integers for arithmetic)
	ret[used_gb]=$(printf %.2f $((100 * ${ret[used_bytes]} / 1024 / 1024 / 1024))e-2)

	echo "$device has ${ret[no_of_partitions]} partitions, last sector ${ret[last_sector]}, sector size ${ret[sector_size]}, used ${ret[used_mb]} Mb, total ${ret[total_bytes]} b"
	#echo "$device has ${ret[used_bytes]} bytes, ${ret[used_mb]} Mb, ${ret[used_gb]} Gb, ${ret[total_sectors]} sectors"
}

# isMounted
# returns a status depending on whether or not a device has any mount points (i.e. the opposite of "mount")
# Usage:
# isMounted <device> [-q]
# 	<device>	The device to check e.g. /dev/sda
#	-q		Quiet mode, no output
# e.g.
# isMounted /dev/sda > /dev/null
# if [[ $? = 0 ]] ; then echo "is mounted"; fi
# Returns:
#	0 if the <device> is mounted
#	1 if the <device> is NOT mounted
#	-1 if <device> is not supplied (i.e. blank)
isMounted() {
	if [ -z "$1" ] ; then
#		echo "-$2-"
		if [ "$2" != "-q" ] ; then
			echo "isMounted needs a parameter"
		fi
		return -1
	fi

	local output="$(findmnt -o SOURCE)"
	local lines
	local i=1
	IFS=$'\n' lines=($output)
	while [ $i -lt ${#lines[@]} ]; do
		if [[ "${lines[$i]}" = $1* ]] ; then
			if [ "$2" != "-q" ] ; then
				echo "$1 is mounted"
			fi
			return 0
		fi 
		i=$((i+1))
	done
	if [ "$2" != "-q" ] ; then
		echo "$1 is not mounted"
	fi
	return 1
}
